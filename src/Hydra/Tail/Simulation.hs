{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedLabels #-}
{-# LANGUAGE TypeApplications #-}

module Hydra.Tail.Simulation where

import Prelude

import Control.Exception
    ( Exception )
import Control.Monad
    ( forM, forM_, forever, join, liftM4, void, when )
import Control.Monad.Class.MonadAsync
    ( MonadAsync
    , async
    , concurrently_
    , forConcurrently_
    , replicateConcurrently_
    )
import Control.Monad.Class.MonadSTM
    ( MonadSTM, TMVar, atomically, newTMVarIO )
import Control.Monad.Class.MonadThrow
    ( MonadThrow, throwIO )
import Control.Monad.Class.MonadTime
    ( MonadTime, Time (..) )
import Control.Monad.Class.MonadTimer
    ( MonadTimer, threadDelay )
import Control.Monad.IOSim
    ( IOSim, ThreadLabel, Trace (..), runSimTrace )
import Control.Monad.Trans.State.Strict
    ( StateT, evalStateT, execStateT, state )
import Control.Tracer
    ( Tracer (..), contramap, traceWith )
import Data.Foldable
    ( traverse_ )
import Data.Functor
    ( ($>) )
import Data.Generics.Internal.VL.Lens
    ( (^.) )
import Data.Generics.Labels
    ()
import Data.List
    ( foldl', maximumBy )
import Data.Map.Strict
    ( Map, (!) )
import Data.Ratio
    ( (%) )
import Data.Text
    ( Text )
import Data.Time.Clock
    ( DiffTime, picosecondsToDiffTime, secondsToDiffTime )
import GHC.Generics
    ( Generic )
import Safe
    ( readMay )
import System.Random
    ( StdGen, newStdGen, randomR )

import qualified Control.Monad.IOSim as IOSim
import qualified Data.Map.Strict as Map
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.IO as TIO

import Hydra.Tail.Simulation.MockTx
    ( MockTx (..), mockTx, received, sent )
import Hydra.Tail.Simulation.Options
    ( ClientOptions (..)
    , NetworkCapacity (..)
    , PrepareOptions (..)
    , RunOptions (..)
    , ServerOptions (..)
    , kbitsPerSecond
    )
import Hydra.Tail.Simulation.PaymentWindow
    ( Balance (..)
    , Lovelace (..)
    , PaymentWindowStatus (..)
    , ada
    , initialBalance
    , modifyCurrent
    , viewPaymentWindow
    )
import Hydra.Tail.Simulation.SlotNo
    ( SlotNo (..) )
import Hydra.Tail.Simulation.Utils
    ( foldTraceEvents
    , frequency
    , modifyM
    , updateF
    , withLabel
    , withTMVar
    , withTMVar_
    )
import HydraSim.Analyse
    ( diffTimeToSeconds )
import HydraSim.DelayedComp
    ( DelayedComp, delayedComp, runComp )
import HydraSim.Examples.Channels
    ( AWSCenters (..), channel )
import HydraSim.Multiplexer
    ( Multiplexer
    , getMessage
    , newMultiplexer
    , reenqueue
    , sendTo
    , startMultiplexer
    )
import HydraSim.Multiplexer.Trace
    ( TraceMultiplexer (..) )
import HydraSim.Sized
    ( Size (..), Sized (..) )
import HydraSim.Tx.Class
    ( Tx (..) )
import HydraSim.Types
    ( NodeId (..) )

import qualified HydraSim.Multiplexer as Multiplexer

--
-- Simulation
--

prepareSimulation :: PrepareOptions -> IO [Event]
prepareSimulation options@PrepareOptions{numberOfClients,duration} = do
  let clientIds = [1..fromInteger numberOfClients]
  let events = fmap join $ forM [0 .. pred duration] $ \currentSlot -> do
        join <$> traverse (stepClient options currentSlot) clientIds
  newStdGen >>= evalStateT events

runSimulation :: RunOptions -> [Event] -> Trace ()
runSimulation opts@RunOptions{slotLength,serverOptions} events = runSimTrace $ do
  let (serverId, clientIds) = (0, [1..fromInteger (getNumberOfClients events)])
  server <- newServer serverId clientIds serverOptions
  clients <- forM clientIds $ \clientId -> do
    client <- newClient clientId
    client <$ connectClient client server
  void $ async $ concurrently_
    (runServer trServer opts server)
    (forConcurrently_ clients (runClient trClient events serverId opts))
  threadDelay (durationOf events slotLength)
 where
  tracer :: Tracer (IOSim a) TraceTailSimulation
  tracer = Tracer IOSim.traceM

  trClient :: Tracer (IOSim a) TraceClient
  trClient = contramap TraceClient tracer

  trServer :: Tracer (IOSim a) TraceServer
  trServer = contramap TraceServer tracer

data Analyze = Analyze
  { maxThroughput :: Double
    -- ^ Throughput as generated by clients
  , actualThroughput :: Double
    -- ^ Actual Throughput measured from confirmed transactions.
    -- Said differently, the ratio of transactions compared to the number of snapshots.
  , actualWriteNetworkUsage :: NetworkCapacity
    -- ^ Actual write network usage used / needed for running the simulation.
  , actualReadNetworkUsage :: NetworkCapacity
    -- ^ Actual read network usage used / needed for running the simulation.
  } deriving (Generic, Show)

data Metric
  = ConfirmedTxs
  | Snapshots
  | WriteUsage
  | ReadUsage
  deriving (Generic, Eq, Ord, Enum, Bounded)

analyzeSimulation
  :: forall m. Monad m
  => (SlotNo -> m ())
  -> RunOptions
  -> SimulationSummary
  -> [Event]
  -> Trace ()
  -> m Analyze
analyzeSimulation notify RunOptions{slotLength} SimulationSummary{numberOfTransactions} events trace = do
  (metrics, _) <-
    let zero :: Map Metric Integer
        zero = Map.fromList [ (k, 0) | k <- [minBound .. maxBound] ]

        fn :: (ThreadLabel, Time, TraceTailSimulation) -> (Map Metric Integer, SlotNo) -> m (Map Metric Integer, SlotNo)
        fn = \case
          (_threadLabel, _time, TraceClient (TraceClientMultiplexer (MPRecvTrailing _nodeId AckTx{}))) ->
            (\(!m, !sl) -> pure (Map.adjust (+ 1) ConfirmedTxs m, sl))

          (_threadLabel, _time, TraceServer (TraceServerMultiplexer (MPRecvLeading _nodeId (Size s)))) ->
            (\(!m, !sl) -> pure (Map.adjust (+ toInteger s) ReadUsage m, sl))

          (_threadLabel, _time, TraceServer (TraceServerMultiplexer (MPSendLeading _nodeId (Size s)))) ->
            (\(!m, !sl) -> pure (Map.adjust (+ toInteger s) WriteUsage m, sl))

          (_threadLabel, _time, TraceClient (TraceClientWakeUp sl')) ->
            (\(!m, !sl) ->
              if sl' > sl then
                notify sl' $> (m, sl')
              else
                pure (m, sl)
            )
          _ ->
            pure

     in foldTraceEvents fn (zero, -1) trace

  let numberOfConfirmedTransactions =
        fromIntegral (metrics ! ConfirmedTxs)

  let duration =
        diffTimeToSeconds (durationOf events slotLength)

  pure $ Analyze
    { maxThroughput =
        fromIntegral (numberOfTransactions ^. #total) / duration
    , actualThroughput =
        numberOfConfirmedTransactions / duration
    , actualWriteNetworkUsage =
        kbitsPerSecond $ (metrics ! WriteUsage) `div` (1024 * round duration)
    , actualReadNetworkUsage =
        kbitsPerSecond $ (metrics ! ReadUsage) `div` (1024 * round duration)
    }

--
-- (Simplified) Tail-Protocol
--

-- | Messages considered as part of the simplified Tail pre-protocol. We don't know exactly
-- what the Tail protocol hence we have a highly simplified view of it and reduce it to a
-- mere message broker between many producers and many consumers (the clients), linked together
-- via a single message broker (the server).
data Msg
  --
  -- ↓↓↓ Client messages ↓↓↓
  --
  = NewTx !MockTx ![ClientId]
  -- ^ A new transaction, sent to some peer. The current behavior of this simulation
  -- consider that each client is only sending to one single peer. Later, we probably
  -- want to challenge this assumption by analyzing real transaction patterns from the
  -- main chain and model this behavior.

  | Pull
  -- ^ Sent when waking up to catch up on messages received when offline.

  | Connect
  -- ^ Client connections and disconnections are modelled using 0-sized messages.

  | Disconnect
  -- ^ Client connections and disconnections are modelled using 0-sized messages.

  | SnapshotDone
  -- ^ Clients informing the server about the end of a snapshot

  --
  -- ↓↓↓ Server messages ↓↓↓
  --

  | NotifyTx !MockTx
  -- ^ The server will notify concerned clients with transactions they have subscribed to.
  -- How clients subscribe and how the server is keeping track of the subscription is currently
  -- out of scope and will be explored at a later stage.

  | NeedSnapshot
  -- ^ The server requests a client to perform a snapshot.

  | AckTx !(TxRef MockTx)
  -- ^ The server replies to each client submitting a transaction with an acknowledgement.
  deriving (Generic, Show)

instance Sized Msg where
  size = \case
    NewTx tx clients ->
      sizeOfHeader + size tx + sizeOfAddress * fromIntegral (length clients)
    Pull ->
      sizeOfHeader
    Connect{} ->
      0
    Disconnect{} ->
      0
    NeedSnapshot{} ->
      0
    SnapshotDone{} ->
      0
    NotifyTx tx ->
      sizeOfHeader + size tx
    AckTx txId ->
      sizeOfHeader + size txId
   where
    sizeOfAddress = 57
    sizeOfHeader = 2

data TraceTailSimulation
  = TraceServer TraceServer
  | TraceClient TraceClient
  deriving (Show)

--
-- Server
--

type ServerId = NodeId

data Server m = Server
  { multiplexer :: Multiplexer m Msg
  , identifier  :: ServerId
  , region :: AWSCenters
  , registry :: TMVar m (Map ClientId (ClientState, Balance, [Msg], [Msg]))
  } deriving (Generic)

newServer
  :: MonadSTM m
  => ServerId
  -> [ClientId]
  -> ServerOptions
  -> m (Server m)
newServer identifier clientIds ServerOptions{region,writeCapacity,readCapacity} = do
  multiplexer <- newMultiplexer
    "server"
    outboundBufferSize
    inboundBufferSize
    (capacity writeCapacity)
    (capacity readCapacity)
  registry <- newTMVarIO clients
  return Server { multiplexer, identifier, region, registry }
 where
  outboundBufferSize = 1000000
  inboundBufferSize = 1000000
  -- NOTE: We care little about how much each client balance is in practice. Although
  -- the 'Balance' is modelled as a product (initial, current) because of the intuitive
  -- view it offers, we are really only interested in the delta. Balances can therefore
  -- be _negative_ as part of the simulation.
  clients = Map.fromList
    [ (clientId, (Offline, initialBalance 0, mempty, mempty))
    | clientId <- clientIds
    ]

runServer
  :: forall m. (MonadAsync m, MonadTimer m, MonadThrow m)
  => Tracer m TraceServer
  -> RunOptions
  -> Server m
  -> m ()
runServer tracer options Server{multiplexer, registry} = do
  concurrently_
    (startMultiplexer (contramap TraceServerMultiplexer tracer) multiplexer)
    (replicateConcurrently_
      (options ^. #serverOptions . #concurrency)
      (withLabel "Main: Server" serverMain)
    )
 where
  reenqueue' = reenqueue (contramap TraceServerMultiplexer tracer)

  serverMain :: m ()
  serverMain = do
    atomically (getMessage multiplexer) >>= \case
      (clientId, NewTx tx recipients) -> do
        void $ runComp (txValidate Set.empty tx)
        void $ runComp lookupClient

        -- Some of the recipients or the sender may be out of their payment window
        -- (i.e. 'Blocked'), if that's the case, we cannot process the transaction
        -- until they are done.
        blocked <- withTMVar registry $ \clients -> (,clients)
            <$> Map.traverseMaybeWithKey
                  (matchBlocked (options ^. #paymentWindow) (clientId, tx, recipients))
                  clients
        if not (null blocked) then do
          forM_ blocked $ flip (sendTo multiplexer) NeedSnapshot
          withTMVar_ registry $ updateF clientId $ \(st, balance, mailbox, pending) ->
            pure $ Just (st, balance, mailbox, NewTx tx recipients:pending)

        else do
          withTMVar_ registry $ \clients -> do
            clients' <- flip execStateT clients $ do
              forM_ recipients $ \recipient -> do
                modifyM $ updateF clientId $ \case
                  (Online, balance, mailbox, pending) -> do
                    sendTo multiplexer recipient (NotifyTx tx)
                    pure $ Just (Online, modifyCurrent (+ received tx recipients) balance , mailbox, pending)
                  (st, balance, mailbox, pending) -> do
                    let msg = NotifyTx tx
                    traceWith tracer $ TraceServerStoreInMailbox clientId msg (length mailbox + 1)
                    pure $ Just (st, modifyCurrent (+ received tx recipients) balance, msg:mailbox, pending)
              modifyM $ updateF clientId $ \(st, balance, mailbox, pending) ->
                pure $ Just (st, modifyCurrent (\x -> x - sent tx) balance, mailbox, pending)
            sendTo multiplexer clientId (AckTx $ txRef tx)
            return clients'

        serverMain

      (clientId, Pull) -> do
        runComp lookupClient
        withTMVar_ registry $ \clients -> do
          updateF clientId (\case
            (st, balance, mailbox, pending) -> do
              mapM_ (sendTo multiplexer clientId) (reverse mailbox)
              pure $ Just (st, balance, [], pending)
            ) clients
        serverMain

      (clientId, Connect) -> do
        runComp lookupClient
        withTMVar_ registry $ \clients -> do
          return $ Map.update (\(_, balance, mailbox, pending) -> Just (Online, balance, mailbox, pending)) clientId clients
        serverMain

      (clientId, Disconnect) -> do
        runComp lookupClient
        withTMVar_ registry $ \clients -> do
          return $ Map.update (\(_, balance, mailbox, pending) -> Just (Offline, balance, mailbox, pending)) clientId clients
        serverMain

      (clientId, SnapshotDone) -> do
        runComp lookupClient
        withTMVar_ registry $ updateF clientId $ \(st, Balance{current}, mailbox, pending) -> do
          traverse_ (reenqueue' multiplexer) (reverse $ (clientId,) <$> pending)
          return $ Just (st, initialBalance current, mailbox, [])
        serverMain

      (clientId, msg) ->
        throwIO (UnexpectedServerMsg clientId msg)

-- | A computation simulating the time needed to lookup a client in an in-memory registry.
-- The value is taken from running benchmarks of the 'containers' Haskell library on a
-- high-end laptop. The time needed to perform a lookup was deemed non negligeable in front of
-- the time needed to validate a transaction.
--
-- Note that a typical hashmap or map is implemented using balanced binary trees and provide a O(log(n))
-- lookup performances, so the cost of looking a client in a map of 1000 or 100000 clients is _roughly the same_.
lookupClient :: DelayedComp ()
lookupClient =
  delayedComp () (picosecondsToDiffTime 500*1e6) -- 500μs

-- | Return 'f (Just ClientId)' iif a client would exceed (bottom or top) its payment window
-- from the requested payment.
--
-- NOTE: There's a slight _abuse_ here. Transactions are indeed written from the PoV
-- of the _sender_. So the amount corresponds to how much did the sender "lost" in the
-- transaction, but, there can be multiple recipients! Irrespective of this, we consider
-- in the simulation that *each* recipient receives the full amount.
matchBlocked
  :: Applicative f
  => Maybe Lovelace
  -> (ClientId, MockTx, [ClientId])
  -> ClientId
  -> (st, Balance, mailbox, pending)
  -> f (Maybe ClientId)
matchBlocked Nothing _ _ _ =
  pure Nothing
matchBlocked (Just paymentWindow) (sender, tx, recipients) clientId (_, balance, _, _)
  | clientId `elem` recipients =
      case viewPaymentWindow paymentWindow balance (received tx recipients) of
        InPaymentWindow ->
          pure Nothing
        OutOfPaymentWindow ->
          pure (Just clientId)

  | clientId == sender =
      case viewPaymentWindow paymentWindow balance (negate $ sent tx) of
        InPaymentWindow ->
          pure Nothing
        OutOfPaymentWindow ->
          pure (Just clientId)

  | otherwise =
      pure Nothing

data TraceServer
  = TraceServerMultiplexer (TraceMultiplexer Msg)
  | TraceServerStoreInMailbox ClientId Msg Int
  deriving (Show)

data ServerMain = ServerMain deriving Show
instance Exception ServerMain

data UnexpectedServerMsg = UnexpectedServerMsg NodeId Msg
  deriving Show
instance Exception UnexpectedServerMsg

data UnknownClient = UnknownClient NodeId
  deriving Show
instance Exception UnknownClient

--
-- Client
--

type ClientId = NodeId

data ClientState = Online | Offline
  deriving (Generic, Show, Eq)

data Client m = Client
  { multiplexer :: Multiplexer m Msg
  , identifier  :: ClientId
  , region :: AWSCenters
  } deriving (Generic)

newClient :: MonadSTM m => ClientId -> m (Client m)
newClient identifier = do
  multiplexer <- newMultiplexer
    ("client-" <> show (getNodeId identifier))
    outboundBufferSize
    inboundBufferSize
    (capacity $ kbitsPerSecond 512)
    (capacity $ kbitsPerSecond 512)
  return Client { multiplexer, identifier, region }
 where
  outboundBufferSize = 1000
  inboundBufferSize = 1000
  region = LondonAWS

runClient
  :: forall m. (MonadAsync m, MonadTimer m, MonadThrow m)
  => Tracer m TraceClient
  -> [Event]
  -> ServerId
  -> RunOptions
  -> Client m
  -> m ()
runClient tracer events serverId opts Client{multiplexer, identifier} = do
  st <- newTMVarIO Offline
  concurrently_
    (startMultiplexer (contramap TraceClientMultiplexer tracer) multiplexer)
    (concurrently_
      (withLabel ("EventLoop: " <> show identifier) $ clientEventLoop st 0 events)
      (withLabel ("Main: " <> show identifier) $ forever $ clientMain st)
    )
 where
  clientMain :: TMVar m ClientState -> m ()
  clientMain var =
    atomically (getMessage multiplexer) >>= \case
      (_, AckTx{}) ->
        pure ()
      (_, NotifyTx{}) ->
        pure ()
      (_, NeedSnapshot{}) -> do
        -- NOTE: Holding on the MVar here prevents the client's event loop from
        -- processing any new event. The other will block until the snapshot is done.
        withTMVar_ var $ \st -> do
          threadDelay settlementDelay_
          sendTo multiplexer serverId SnapshotDone
          pure st
      (nodeId, msg) ->
        throwIO $ UnexpectedClientMsg nodeId msg
   where
    settlementDelay_ =
      secondsToDiffTime (unSlotNo (opts ^. #settlementDelay))
      *
      (opts ^. #slotLength)

  clientEventLoop :: TMVar m ClientState -> SlotNo -> [Event] -> m ()
  clientEventLoop !var !currentSlot = \case
    [] ->
      pure ()

    (e:q) | from e /= identifier ->
      clientEventLoop var currentSlot q

    (e:q) | slot e <= currentSlot -> do
      withTMVar_ var $ \st -> do
        when (st == Offline) $ do
          traceWith tracer (TraceClientWakeUp currentSlot)
          sendTo multiplexer serverId Connect
        Online <$ sendTo multiplexer serverId (msg e)
      clientEventLoop var currentSlot q

    (e:q) -> do
      withTMVar_ var $ \st ->
        Offline <$ when (st == Online) (sendTo multiplexer serverId Disconnect)
      threadDelay (opts ^. #slotLength)
      clientEventLoop var (currentSlot + 1) (e:q)

data UnexpectedClientMsg = UnexpectedClientMsg NodeId Msg
  deriving Show
instance Exception UnexpectedClientMsg

stepClient
  :: forall m. (Monad m)
  => PrepareOptions
  -> SlotNo
  -> ClientId
  -> StateT StdGen m [Event]
stepClient options currentSlot identifier = do
  pOnline <- state (randomR (1, 100))
  let online = pOnline % 100 <= onlineLikelihood
  pSubmit <- state (randomR (1, 100))
  let submit = online && (pSubmit % 100 <= submitLikelihood)
  recipient <- pickRecipient identifier (options ^. #numberOfClients)

  -- NOTE: The distribution is extrapolated from real mainchain data.
  amount <- fmap ada $ state $ frequency
    [ (122, randomR (1, 10))
    , (144, randomR (10, 100))
    , (143, randomR (100, 1000))
    , ( 92, randomR (1000, 10000))
    , ( 41, randomR (10000, 100000))
    , ( 12, randomR (100000, 1000000))
    ]

  -- NOTE: The distribution is extrapolated from real mainchain data.
  txSize <- fmap Size $ state $ frequency
    [ (318, randomR (192, 512))
    , (129, randomR (512, 1024))
    , (37, randomR (1024, 2048))
    , (12, randomR (2048, 4096))
    , (43, randomR (4096, 8192))
    , (17, randomR (8192, 16384))
    ]

  pure
    [ Event currentSlot identifier msg
    | (predicate, msg) <-
        [ ( online
          , Pull
          )
        , ( submit
          , NewTx (mockTx identifier currentSlot amount txSize) [recipient]
          )
        ]
    , predicate
    ]
 where
  ClientOptions { onlineLikelihood, submitLikelihood } = options ^. #clientOptions

data TraceClient
  = TraceClientMultiplexer (TraceMultiplexer Msg)
  | TraceClientWakeUp SlotNo
  deriving (Show)

--
-- Events
--

-- In this simulation, we have decoupled the generation of events from their
-- processing. 'Event's are used as an interface, serialized to CSV. This way,
-- the simulation can be fed with data coming from various places.
data Event = Event
  { slot :: !SlotNo
  , from :: !ClientId
  , msg :: !Msg
  } deriving (Generic, Show)

data SimulationSummary = SimulationSummary
  { numberOfClients :: !Integer
  , numberOfEvents :: !Integer
  , numberOfTransactions :: !NumberOfTransactions
  , lastSlot :: !SlotNo
  } deriving (Generic, Show)

data NumberOfTransactions = NumberOfTransactions
  { total :: !Integer
  , belowPaymentWindow :: !Integer
  , belowHalfOfPaymentWindow :: !Integer
  , belowTenthOfPaymentWindow :: !Integer
  } deriving (Generic, Show)

summarizeEvents :: RunOptions -> [Event] -> SimulationSummary
summarizeEvents RunOptions{paymentWindow} events = SimulationSummary
  { numberOfClients
  , numberOfEvents
  , numberOfTransactions
  , lastSlot
  }
 where
  numberOfEvents = toInteger $ length events
  numberOfClients = getNumberOfClients events
  numberOfTransactions = foldl' count (NumberOfTransactions 0 0 0 0) events
   where
    w = maybe 1e99 asDouble paymentWindow
    count st = \case
      (Event _ _ (NewTx MockTx{txAmount} _)) -> st
        { total =
            countIf True st total
        , belowPaymentWindow =
            countIf (asDouble txAmount <= w) st belowPaymentWindow
        , belowHalfOfPaymentWindow =
            countIf (asDouble txAmount <= (w / 2)) st belowHalfOfPaymentWindow
        , belowTenthOfPaymentWindow =
            countIf (asDouble txAmount <= (w / 10)) st belowTenthOfPaymentWindow
        }
      _ -> st
    countIf predicate st get =
      if predicate then get st + 1 else get st
    asDouble = fromIntegral @_ @Double . unLovelace

  lastSlot = last events ^. #slot

durationOf :: [Event] -> DiffTime -> DiffTime
durationOf events slotLength =
  slotLength * fromIntegral (unSlotNo $ succ $ last events ^. #slot)

getNumberOfClients :: [Event] -> Integer
getNumberOfClients =
  toInteger . getNodeId . from . maximumBy (\a b -> getNodeId (from a) `compare` getNodeId (from b))

data CouldntParseCsv = CouldntParseCsv FilePath
  deriving Show
instance Exception CouldntParseCsv

writeEvents :: FilePath -> [Event] -> IO ()
writeEvents filepath events = do
  TIO.writeFile filepath $ T.unlines $
    "slot,clientId,event,size,amount,recipients"
    : (eventToCsv <$> events)

readEventsThrow :: FilePath -> IO [Event]
readEventsThrow filepath = do
  text <- TIO.readFile filepath
  case traverse eventFromCsv . drop 1 . T.lines $ text of
    Nothing -> throwIO $ CouldntParseCsv filepath
    Just events -> pure events

eventToCsv :: Event -> Text
eventToCsv = \case
  -- slot,clientId,'pull'
  Event (SlotNo sl) (NodeId cl) Pull ->
    T.intercalate ","
      [ T.pack (show sl)
      , T.pack (show cl)
      , "pull"
      ]

  -- slot,clientId,new-tx,size,amount,recipients
  Event (SlotNo sl) (NodeId cl) (NewTx (MockTx _ (Size sz) (Lovelace am)) rs) ->
    T.intercalate ","
      [ T.pack (show sl)
      , T.pack (show cl)
      , "new-tx"
      , T.pack (show sz)
      , T.pack (show am)
      , T.intercalate " " (T.pack . show . getNodeId <$> rs)
      ]

  e ->
    error $ "eventToCsv: invalid event to serialize: " <> show e

eventFromCsv :: Text -> Maybe Event
eventFromCsv line =
  case T.splitOn "," line of
    -- slot,clientId,'pull'
    (sl: (cl: ("pull": _))) -> Event
        <$> readSlotNo sl
        <*> readClientId cl
        <*> pure Pull

    -- slot,clientId,new-tx,size,amount,recipients
    [ sl, cl, "new-tx", sz, am, rs ] -> Event
        <$> readSlotNo sl
        <*> readClientId cl
        <*> (NewTx
          <$> liftM4 mockTx (readClientId cl) (readSlotNo sl) (readAmount am) (readSize sz)
          <*> readRecipients rs
        )


    _ ->
      Nothing
 where
  readClientId :: Text -> Maybe ClientId
  readClientId =
    fmap NodeId . readMay . T.unpack

  readSlotNo :: Text -> Maybe SlotNo
  readSlotNo =
    fmap SlotNo . readMay . T.unpack

  readAmount :: Text -> Maybe Lovelace
  readAmount =
    readMay . T.unpack

  readSize :: Text -> Maybe Size
  readSize =
    fmap Size . readMay . T.unpack

  readRecipients :: Text -> Maybe [ClientId]
  readRecipients = \case
    "" -> Just []
    ssv -> traverse readClientId (T.splitOn " " ssv)

--
-- Helpers
--

getRegion
  :: [AWSCenters]
  -> NodeId
  -> AWSCenters
getRegion regions (NodeId i) =
  regions !! (i `mod` length regions)

pickRecipient
  :: Monad m
  => ClientId
  -> Integer
  -> StateT StdGen m ClientId
pickRecipient (NodeId me) n = do
  i <- state (randomR (1, n))
  if i == fromIntegral me then
    pickRecipient (NodeId me) n
  else
    pure $ NodeId (fromIntegral i)

connectClient
  :: (MonadAsync m, MonadTimer m, MonadTime m)
  => Client m
  -> Server m -> m ()
connectClient client server =
  Multiplexer.connect
    ( channel (client ^. #region) (server ^. #region) )
    ( client ^. #identifier, client ^. #multiplexer )
    ( server ^. #identifier, server ^. #multiplexer )
